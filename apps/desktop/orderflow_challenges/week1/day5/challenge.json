{
  "id": "w1d5-challenge",
  "title": "Full Simulator",
  "description": "Build the complete order flow simulator integrating all components from the week.",
  "instructions": "## Goal\n\nIntegrate all components (events, state, RNG, agents, metrics) into a working simulator.\n\n## Requirements\n\n1. Create a simulation loop that:\n   - Initializes state, metrics, and agents with a seed\n   - Runs for N ticks\n   - Each tick: agents generate actions → engine processes → metrics update\n   - Returns a deterministic summary\n\n2. Implement `fn run(seed: u64, ticks: u32) -> SimResult` where SimResult includes:\n   - Total events processed\n   - Final metrics (orders, cancels, fills)\n   - A fingerprint string for golden testing\n\n3. Add a golden test proving determinism:\n   - Fixed seed + ticks = exact expected fingerprint\n\n## Integration Points\n\n- Reuse your Rng, Event, State, Metrics from previous days\n- Include at least 2 agents (NoiseTrader, CancelBot)\n- Process agents in stable order (sorted by ID)",
  "starter_code": "// Import all your components from previous days here\n\nstruct SimResult {\n    total_events: u64,\n    total_orders: u64,\n    total_cancels: u64,\n    total_fills: u64,\n    fingerprint: String,\n}\n\nfn run(seed: u64, ticks: u32) -> SimResult {\n    // TODO: Initialize RNG, state, metrics, agents\n    // TODO: Run simulation loop\n    // TODO: Return deterministic result\n    todo!()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn golden_determinism_test() {\n        let result = run(42, 100);\n        // TODO: Assert exact fingerprint\n    }\n\n    #[test]\n    fn same_seed_same_result() {\n        let r1 = run(42, 100);\n        let r2 = run(42, 100);\n        assert_eq!(r1.fingerprint, r2.fingerprint);\n    }\n}",
  "test_code": "#[cfg(test)]\nmod solution_tests {\n    use super::*;\n\n    #[test]\n    fn test_determinism() {\n        let r1 = run(123, 50);\n        let r2 = run(123, 50);\n        assert_eq!(r1.total_events, r2.total_events);\n        assert_eq!(r1.fingerprint, r2.fingerprint);\n    }\n\n    #[test]\n    fn test_different_seeds_differ() {\n        let r1 = run(42, 50);\n        let r2 = run(99, 50);\n        assert_ne!(r1.fingerprint, r2.fingerprint);\n    }\n\n    #[test]\n    fn test_events_processed() {\n        let r = run(42, 100);\n        assert!(r.total_events > 0);\n        assert!(r.total_orders > 0);\n    }\n}",
  "solution": "// This is a conceptual solution - actual implementation depends on your previous code\n\nfn run(seed: u64, ticks: u32) -> SimResult {\n    let mut rng = Rng::new(seed);\n    let mut state = State::default();\n    let mut metrics = Metrics::default();\n    let mut agents: Vec<Box<dyn Agent>> = vec![\n        Box::new(NoiseTrader { id: 1 }),\n        Box::new(CancelBot { id: 2 }),\n    ];\n    \n    let mut total_events = 0u64;\n    \n    for tick in 0..ticks {\n        // Sort agents for deterministic order\n        agents.sort_by_key(|a| a.id());\n        \n        let ctx = Ctx {\n            tick,\n            regime: determine_regime(tick, &metrics),\n            open_ids: state.open.clone(),\n        };\n        \n        // Collect all actions\n        for agent in agents.iter_mut() {\n            let actions = agent.step(&ctx, &mut rng);\n            for action in actions {\n                if let Some(event) = process_action(&mut state, action) {\n                    metrics.apply(&event);\n                    total_events += 1;\n                }\n            }\n        }\n    }\n    \n    let fingerprint = format!(\n        \"events={};orders={};cancels={};fills={}\",\n        total_events, metrics.total_orders, metrics.total_cancels, metrics.total_fills\n    );\n    \n    SimResult {\n        total_events,\n        total_orders: metrics.total_orders,\n        total_cancels: metrics.total_cancels,\n        total_fills: metrics.total_fills,\n        fingerprint,\n    }\n}",
  "hints": [
    "Start by copying and integrating code from days 1-4",
    "Process agents in sorted order by ID for determinism",
    "The fingerprint should include key metrics for easy comparison",
    "Use a simple regime determination (e.g., based on tick ranges)"
  ],
  "difficulty": "very-hard",
  "skills": ["cli", "integration", "testing"]
}
