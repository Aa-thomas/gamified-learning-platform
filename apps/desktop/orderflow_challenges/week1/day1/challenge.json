{
  "id": "w1d1-challenge",
  "title": "Apply Event State Machine",
  "description": "Build the smallest 'event → state transition' core you can test, with no panics and deterministic behavior.",
  "instructions": "## Goal\n\nBuild a minimal event → state transition core that is:\n- Testable without I/O\n- Deterministic\n- Panic-free (uses Result instead of unwrap/expect)\n\n## Requirements\n\n1. Define the following types:\n   - `enum Event { New(u32), Cancel(u32) }`\n   - `struct State { open: Vec<u32> }`\n   - `enum DomainErr { UnknownId(u32) }`\n\n2. Implement `fn apply(state: &mut State, e: Event) -> Result<(), DomainErr>`:\n   - `New(id)` adds the id to `open`\n   - `Cancel(id)` removes if present, else returns `Err(DomainErr::UnknownId(id))`\n\n3. Add 2 tests:\n   - Canceling an existing id removes it\n   - Canceling an unknown id returns the correct error and does not change state\n\n## Guardrails\n\n- No `unwrap/expect` in your library code\n- Deterministic output: tests must not depend on printing/logging\n- Keep functions small and single-purpose",
  "starter_code": "#[derive(Clone, Debug, PartialEq, Eq)]\nenum Event {\n    // TODO: Define variants\n}\n\n#[derive(Debug, PartialEq, Eq)]\nenum DomainErr {\n    // TODO: Define error variants\n}\n\n#[derive(Default)]\nstruct State {\n    open: Vec<u32>,\n}\n\nfn apply(state: &mut State, e: Event) -> Result<(), DomainErr> {\n    // TODO: Implement\n    todo!()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn cancel_existing_removes_it() {\n        // TODO: Implement test\n    }\n\n    #[test]\n    fn cancel_unknown_returns_error() {\n        // TODO: Implement test\n    }\n}",
  "test_code": "#[cfg(test)]\nmod solution_tests {\n    use super::*;\n\n    #[test]\n    fn test_new_adds_to_open() {\n        let mut state = State::default();\n        assert!(apply(&mut state, Event::New(1)).is_ok());\n        assert_eq!(state.open, vec![1]);\n    }\n\n    #[test]\n    fn test_cancel_existing_removes() {\n        let mut state = State { open: vec![1, 2, 3] };\n        assert!(apply(&mut state, Event::Cancel(2)).is_ok());\n        assert_eq!(state.open, vec![1, 3]);\n    }\n\n    #[test]\n    fn test_cancel_unknown_returns_error() {\n        let mut state = State { open: vec![1, 2] };\n        let result = apply(&mut state, Event::Cancel(99));\n        assert_eq!(result, Err(DomainErr::UnknownId(99)));\n        assert_eq!(state.open, vec![1, 2]); // State unchanged\n    }\n\n    #[test]\n    fn test_multiple_operations() {\n        let mut state = State::default();\n        apply(&mut state, Event::New(1)).unwrap();\n        apply(&mut state, Event::New(2)).unwrap();\n        apply(&mut state, Event::Cancel(1)).unwrap();\n        apply(&mut state, Event::New(3)).unwrap();\n        assert_eq!(state.open, vec![2, 3]);\n    }\n}",
  "solution": "#[derive(Clone, Debug, PartialEq, Eq)]\nenum Event {\n    New(u32),\n    Cancel(u32),\n}\n\n#[derive(Debug, PartialEq, Eq)]\nenum DomainErr {\n    UnknownId(u32),\n}\n\n#[derive(Default)]\nstruct State {\n    open: Vec<u32>,\n}\n\nfn apply(state: &mut State, e: Event) -> Result<(), DomainErr> {\n    match e {\n        Event::New(id) => {\n            state.open.push(id);\n            Ok(())\n        }\n        Event::Cancel(id) => {\n            state.open\n                .iter()\n                .position(|&x| x == id)\n                .map(|i| { state.open.remove(i); })\n                .ok_or(DomainErr::UnknownId(id))\n        }\n    }\n}",
  "hints": [
    "Use `match` to handle the different event variants",
    "For Cancel, use `iter().position()` to find the index, then `remove()` to delete",
    "The `.ok_or()` method converts Option<T> to Result<T, E>"
  ],
  "difficulty": "medium",
  "skills": ["enums", "match", "testing"]
}
