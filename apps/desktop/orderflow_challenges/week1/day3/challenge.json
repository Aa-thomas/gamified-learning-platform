{
  "id": "w1d3-challenge",
  "title": "Two Agents Implementation",
  "description": "Implement two agents that generate different deterministic actions under different regimes.",
  "instructions": "## Goal\n\nImplement two agents that generate different deterministic actions and prove their behavior changes with regime.\n\n## Requirements\n\n1. Define:\n   - `enum Regime { Calm, Burst, CancelStorm }`\n   - `struct Ctx { tick: u32, regime: Regime, open_ids: Vec<u32> }`\n   - `enum Action { Place(u32), Cancel(u32) }`\n   - `trait Agent { fn id(&self) -> u32; fn step(&mut self, ctx: &Ctx, rng: &mut Rng) -> Vec<Action>; }`\n\n2. Implement two agents:\n   - **NoiseTrader**: In `Calm` places 1 order every 2 ticks; in `Burst` places 3 orders per tick; in `CancelStorm` places 0-1.\n   - **CancelBot**: In `CancelStorm` emits up to 3 cancels targeting IDs from `ctx.open_ids`; otherwise emits 0-1.\n\n3. Tests:\n   - With fixed seed, tick, and open_ids: `CancelBot` in `CancelStorm` produces **more cancels** than in `Calm`.\n   - `NoiseTrader` in `Burst` produces **more places** than in `Calm`.\n\n## Guardrails\n\n- No `unwrap/expect` in library code\n- Deterministic: all randomness comes from `&mut Rng`\n- Any selection from `open_ids` must be stable (don't mutate/sort nondeterministically)",
  "starter_code": "#[derive(Clone, Copy)]\nenum Regime { Calm, Burst, CancelStorm }\n\nstruct Ctx {\n    tick: u32,\n    regime: Regime,\n    open_ids: Vec<u32>,\n}\n\n#[derive(Debug, PartialEq)]\nenum Action { Place(u32), Cancel(u32) }\n\ntrait Agent {\n    fn id(&self) -> u32;\n    fn step(&mut self, ctx: &Ctx, rng: &mut Rng) -> Vec<Action>;\n}\n\n// Copy Rng from Day 2\nstruct Rng { state: u64 }\nimpl Rng {\n    fn new(seed: u64) -> Self { Self { state: seed } }\n    fn next_u32(&mut self) -> u32 {\n        self.state = self.state.wrapping_mul(6364136223846793005).wrapping_add(1);\n        (self.state >> 32) as u32\n    }\n}\n\nstruct NoiseTrader { id: u32 }\n// TODO: Implement Agent for NoiseTrader\n\nstruct CancelBot { id: u32 }\n// TODO: Implement Agent for CancelBot",
  "test_code": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn noise_trader_burst_more_than_calm() {\n        let mut rng = Rng::new(7);\n        let mut trader = NoiseTrader { id: 1 };\n        \n        let calm_ctx = Ctx { tick: 10, regime: Regime::Calm, open_ids: vec![] };\n        let burst_ctx = Ctx { tick: 10, regime: Regime::Burst, open_ids: vec![] };\n        \n        let calm_actions = trader.step(&calm_ctx, &mut rng);\n        let mut rng2 = Rng::new(7);\n        let burst_actions = trader.step(&burst_ctx, &mut rng2);\n        \n        assert!(burst_actions.len() > calm_actions.len());\n    }\n\n    #[test]\n    fn cancel_bot_storm_more_than_calm() {\n        let mut rng = Rng::new(7);\n        let mut bot = CancelBot { id: 2 };\n        let open_ids = vec![1, 2, 3, 4, 5];\n        \n        let calm_ctx = Ctx { tick: 10, regime: Regime::Calm, open_ids: open_ids.clone() };\n        let storm_ctx = Ctx { tick: 10, regime: Regime::CancelStorm, open_ids: open_ids.clone() };\n        \n        let calm_cancels: Vec<_> = trader.step(&calm_ctx, &mut rng).into_iter().filter(|a| matches!(a, Action::Cancel(_))).collect();\n        let mut rng2 = Rng::new(7);\n        let storm_cancels: Vec<_> = bot.step(&storm_ctx, &mut rng2).into_iter().filter(|a| matches!(a, Action::Cancel(_))).collect();\n        \n        assert!(storm_cancels.len() > calm_cancels.len());\n    }\n}",
  "solution": "impl Agent for NoiseTrader {\n    fn id(&self) -> u32 { self.id }\n    \n    fn step(&mut self, ctx: &Ctx, rng: &mut Rng) -> Vec<Action> {\n        match ctx.regime {\n            Regime::Calm => {\n                if ctx.tick % 2 == 0 {\n                    vec![Action::Place(rng.next_u32() % 1000)]\n                } else {\n                    vec![]\n                }\n            }\n            Regime::Burst => {\n                (0..3).map(|_| Action::Place(rng.next_u32() % 1000)).collect()\n            }\n            Regime::CancelStorm => {\n                if rng.next_u32() % 2 == 0 {\n                    vec![Action::Place(rng.next_u32() % 1000)]\n                } else {\n                    vec![]\n                }\n            }\n        }\n    }\n}\n\nimpl Agent for CancelBot {\n    fn id(&self) -> u32 { self.id }\n    \n    fn step(&mut self, ctx: &Ctx, rng: &mut Rng) -> Vec<Action> {\n        if ctx.open_ids.is_empty() { return vec![]; }\n        \n        match ctx.regime {\n            Regime::CancelStorm => {\n                (0..3.min(ctx.open_ids.len()))\n                    .map(|i| Action::Cancel(ctx.open_ids[i]))\n                    .collect()\n            }\n            _ => {\n                if rng.next_u32() % 2 == 0 {\n                    vec![Action::Cancel(ctx.open_ids[0])]\n                } else {\n                    vec![]\n                }\n            }\n        }\n    }\n}",
  "hints": [
    "Use match on ctx.regime to vary behavior",
    "For CancelBot, safely index into open_ids using bounds checking",
    "Remember: all randomness must come from the passed-in rng"
  ],
  "difficulty": "hard",
  "skills": ["traits", "agents", "testing"]
}
